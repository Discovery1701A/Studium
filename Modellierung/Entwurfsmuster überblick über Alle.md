Die verschiedenen Entwurfsmuster nach ihren Arten (kategorisiert nach der "Gang of Four" Kategorisierung) ordnet:

| **Kategorie**        | **Entwurfsmuster**      | **Problembeschreibung**                                                                                                                                                 | **Lösungsbeschreibung**                                                                                                                                                                 | **Konsequenzen**                                                                                                                                                                                                 |
| -------------------- | ----------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Erzeugungsmuster** | Singleton               | Es soll genau eine Instanz einer Klasse geben und diese Instanz soll global zugänglich sein.                                                                            | Stellt sicher, dass eine Klasse nur eine Instanz hat und bietet einen globalen Zugriffspunkt auf diese Instanz.                                                                         | Kontrollierter Zugriff auf die einzige Instanz, Möglichkeit zur Kontrolle der Anzahl von Instanzen, kann zu Problemen beim Testen und Parallelität führen.                                                       |
|                      | Factory Method          | Eine Klasse kann ihre Unterklassen nicht instanziieren oder die genauen Klassen der Objekte, die sie erstellt, nicht kennen.                                            | Definiert eine Schnittstelle zur Erstellung eines Objekts, lässt aber Unterklassen entscheiden, welche Klasse instanziiert wird.                                                        | Erleichtert die Erstellung von Objekten und die Erweiterbarkeit von Code, kann zu einer großen Anzahl von Klassen führen.                                                                                        |
|                      | Abstract Factory        | Eine Klasse soll eine Familie verwandter oder abhängiger Objekte erstellen können, ohne ihre konkreten Klassen zu kennen.                                               | Stellt eine Schnittstelle zum Erstellen von Familien verwandter Objekte bereit, ohne deren konkrete Klassen zu spezifizieren.                                                           | Erleichtert den Austausch von Produktfamilien, sorgt für Konsistenz zwischen den Produkten, kann komplexe und schwer zu wartende Implementierungen erfordern.                                                    |
|                      | Builder                 | Die Konstruktion eines komplexen Objekts soll von seiner Repräsentation getrennt werden, damit dieselbe Konstruktionsweise verschiedene Darstellungen ermöglichen kann. | Trennt die Konstruktion eines komplexen Objekts von seiner Repräsentation, indem es Schritt-für-Schritt-Konstruktionsmethoden bereitstellt.                                             | Ermöglicht unterschiedliche Darstellungen desselben Objekts, verbessert die Lesbarkeit und Wartbarkeit des Codes, kann zu einer größeren Anzahl von Klassen führen.                                              |
|                      | Prototype               | Erstellen von neuen Objekten durch Kopieren eines Prototyp-Objekts anstelle der Instanziierung neuer Objekte.                                                           | Erlaubt das Kopieren vorhandener Objekte (Prototypen) und das Erstellen neuer Objekte durch diese Kopien.                                                                               | Reduziert die Anzahl der Unterklassen, bietet Flexibilität bei der Erstellung neuer Objekte, kann schwierig sein, tiefgehende Kopien von komplexen Objekten zu implementieren.                                   |
| **Strukturmuster**   | Adapter                 | Schnittstellen inkompatibler Klassen sollen überbrückt werden.                                                                                                          | Wandelt die Schnittstelle einer Klasse in eine andere Schnittstelle um, die der Kunde erwartet.                                                                                         | Erlaubt das Zusammenarbeiten von Klassen, die ansonsten inkompatibel wären, kann zu einer höheren Komplexität führen.                                                                                            |
|                      | Composite               | Strukturierung von Objekten in Baumstrukturen, um Teil-Ganzes-Hierarchien darzustellen.                                                                                 | Stellt sicher, dass einzelne Objekte und Objektkompositionen gleich behandelt werden können.                                                                                            | Erleichtert die Arbeit mit hierarchischen Baumstrukturen, ermöglicht die Rekursion über Baumelemente, kann zu einer komplexen Implementierung und schwieriger Fehlerbehebung führen.                             |
|                      | Decorator               | Dynamisches Hinzufügen von Zuständigkeiten zu einem Objekt zur Laufzeit.                                                                                                | Verwendet Wrapper-Objekte (Dekorierer), die die gleiche Schnittstelle wie das ursprüngliche Objekt implementieren und zusätzliche Funktionalitäten hinzufügen.                          | Flexible Erweiterung von Funktionalitäten, aber potenziell viele kleine Objekte, die schwer zu verwalten sind.                                                                                                   |
|                      | Façade                  | Bereitstellung einer einheitlichen Schnittstelle für eine Menge von Schnittstellen in einem Subsystem.                                                                  | Bietet eine höhere Ebene der Schnittstelle, die ein Subsystem einfacher zugänglich macht.                                                                                               | Vereinfacht die Nutzung eines Subsystems, reduziert die Abhängigkeiten zwischen den Client-Code und dem Subsystem, kann eine zusätzliche Abstraktionsschicht einführen, die die Leistung beeinträchtigen könnte. |
|                      | Flyweight               | Unterstützung einer großen Anzahl feiner granularer Objekte effizient.                                                                                                  | Teilt Zustände zwischen Objekten, um die Speicherverwendung zu minimieren.                                                                                                              | Reduziert den Speicherbedarf, erhöht die Komplexität des Codes durch das Teilen von Zuständen zwischen Objekten.                                                                                                 |
|                      | Proxy                   | Bereitstellung eines Stellvertreters für den Zugriff auf ein Objekt.                                                                                                    | Kontrolliert den Zugriff auf ein Objekt durch Bereitstellung eines Stellvertreters.                                                                                                     | Erlaubt zusätzliche Kontrolle und Optimierung, wie z. B. lazy initialization oder Zugriffsrechte, kann die Komplexität erhöhen und die Leistung beeinträchtigen.                                                 |
| **Verhaltensmuster** | State                   | Ein Objekt verhält sich unterschiedlich, abhängig von seinem internen Zustand.                                                                                          | Kapselt zustandsspezifisches Verhalten in Zustandsklassen und delegiert Zustandsänderungen an diese Klassen.                                                                            | Zustandsabhängiges Verhalten wird auf einfache Weise geändert, Zustandsklassen können erweitert werden, ohne das Kontextobjekt zu ändern, kann die Anzahl der Klassen erhöhen.                                   |
|                      | Observer                | Ein Objekt ändert seinen Zustand, und mehrere andere Objekte müssen über diese Änderung informiert werden.                                                              | Definiert eine Eins-zu-viele-Abhängigkeit zwischen Objekten, sodass, wenn ein Objekt seinen Zustand ändert, alle abhängigen Objekte benachrichtigt und automatisch aktualisiert werden. | Entkoppelt Subjekte und Beobachter, unterstützt Broadcast-Kommunikation, kann zu unvorhersehbaren Änderungen führen, wenn viele Beobachter vorhanden sind.                                                       |
|                      | Strategy                | Es gibt mehrere mögliche Algorithmen für eine Aufgabe, und der Algorithmus soll zur Laufzeit ausgewählt werden können.                                                  | Definiert eine Familie von Algorithmen, kapselt jeden einzelnen und macht sie untereinander austauschbar.                                                                               | Algorithmen können unabhängig voneinander variieren, vermeidet bedingte Anweisungen, kann zu einer großen Anzahl von Klassen führen.                                                                             |
|                      | Command                 | Ein Objekt soll eine Anforderung an ein anderes Objekt zu einem späteren Zeitpunkt ausführen.                                                                           | Kapselt eine Anforderung als Objekt und erlaubt es, Parameter für die Anforderung zu spezifizieren, das Logging und das Undo von Anfragen zu unterstützen.                              | Erlaubt das Speichern von Befehlen zur späteren Ausführung, unterstützt Undo-Operationen, erhöht die Komplexität durch das Hinzufügen zusätzlicher Klassen für jeden Befehl.                                     |
|                      | Chain of Responsibility | Mehrere Objekte sollen die Möglichkeit haben, eine Anforderung zu behandeln.                                                                                            | Verkettet die empfangenden Objekte und gibt die Anforderung entlang der Kette weiter, bis ein Objekt sie behandelt.                                                                     | Entkoppelt Sender und Empfänger von Anfragen, ermöglicht dynamische Bestimmung der Zuständigkeiten, kann schwer zu debuggen und zu verfolgen sein, welche Objekte in der Kette beteiligt sind.                   |
|                      | Interpreter             | Bestimmen und Auswerten der Grammatik einer einfachen Sprache.                                                                                                          | Definiert eine Grammatik für die Sprache und verwendet einen Interpreter, der Sätze in dieser Sprache auswertet.                                                                        | Einfach zu erweiternde und änderbare Grammatik, kann ineffizient sein und für komplexe Sprachen ungeeignet.                                                                                                      |
|                      | Iterator                | Zugriff auf die Elemente eines Aggregats, ohne seine interne Darstellung zu offenbaren.                                                                                 | Bietet eine einheitliche Methode, um auf die Elemente einer Aggregatstruktur zuzugreifen, ohne die zugrunde liegende Struktur zu exponieren.                                            | Vereinfacht den Zugriff auf Elemente in einer Sammlung, ermöglicht verschiedene Traversierungsstrategien, kann die Anzahl der Klassen erhöhen.                                                                   |
|                      | Mediator                | Interaktion zwischen einer Menge von Objekten, die sich gegenseitig beeinflussen, steuern.                                                                              | Definiert ein Objekt, das die Kommunikation zwischen einer Gruppe von Objekten kapselt und steuert.                                                                                     | Reduziert die Kopplung zwischen den Klassen, zentralisiert die Steuerung der Interaktion, kann zu einem "God Object" führen, das zu viel Verantwortung trägt.                                                    |
|                      | Memento                 | Erfassen und späteres Wiederherstellen des internen Zustands eines Objekts, ohne seine Implementierungsdetails preiszugeben.                                            | Speichert den internen Zustand eines Objekts, sodass es später wiederhergestellt werden kann.                                                                                           | Erlaubt das Rückgängigmachen von Änderungen, erfordert sorgfältige Verwaltung des gespeicherten Zustands, kann den Speicherbedarf erhöhen.                                                                       |
|                      | Template Method         | Definieren des Gerüsts eines Algorithmus in einer Methode, wobei einige Schritte von Unterklassen implementiert werden.                                                 | Schreibt den Algorithmus in der Basisklasse vor und erlaubt den Unterklassen, einige Schritte des Algorithmus zu überschreiben.                                                         | Erlaubt die Wiederverwendung von Code, erzwingt eine konsistente Struktur für die Unterklassen, kann zu starren Strukturen führen, wenn der Algorithmus häufig geändert werden muss.                             |
|                      | Visitor                 | Operationen über eine Objektstruktur definieren, ohne die Klassen der Objekte zu ändern.                                                                                | Trennt einen Algorithmus von der Objektstruktur, auf der er operiert, indem die Struktur durch Besucherobjekte erweitert wird.                                                          | Erlaubt das Hinzufügen neuer Operationen, ohne die Klassen der Elemente zu ändern, kann die Objektstruktur komplexer machen und die Wartbarkeit erschweren.                                                      |


Diese Tabelle fasst die verschiedenen Entwurfsmuster nach ihren Arten zusammen, bietet eine kurze Problembeschreibung, eine Lösungsbeschreibung und die Konsequenzen jeder Lösung. Diese Informationen sind nützlich, um zu verstehen, welches Muster für ein bestimmtes Problem am besten geeignet ist und welche Vor- und Nachteile die Implementierung des Musters mit sich bringt.